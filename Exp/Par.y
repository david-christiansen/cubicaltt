-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Exp.Par where
import Exp.Abs
import Exp.Lex
import Exp.ErrM

}

%name pModule Module
%name pExp Exp
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  '-' { PT _ (TS _ 5) }
  '->' { PT _ (TS _ 6) }
  '.1' { PT _ (TS _ 7) }
  '.2' { PT _ (TS _ 8) }
  '0' { PT _ (TS _ 9) }
  '1' { PT _ (TS _ 10) }
  ':' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '@' { PT _ (TS _ 16) }
  'Glue' { PT _ (TS _ 17) }
  'Id' { PT _ (TS _ 18) }
  'PathP' { PT _ (TS _ 19) }
  'U' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  '\\' { PT _ (TS _ 22) }
  '\\/' { PT _ (TS _ 23) }
  ']' { PT _ (TS _ 24) }
  'comp' { PT _ (TS _ 25) }
  'data' { PT _ (TS _ 26) }
  'fill' { PT _ (TS _ 27) }
  'glue' { PT _ (TS _ 28) }
  'hdata' { PT _ (TS _ 29) }
  'idC' { PT _ (TS _ 30) }
  'idJ' { PT _ (TS _ 31) }
  'import' { PT _ (TS _ 32) }
  'in' { PT _ (TS _ 33) }
  'let' { PT _ (TS _ 34) }
  'module' { PT _ (TS _ 35) }
  'mutual' { PT _ (TS _ 36) }
  'opaque' { PT _ (TS _ 37) }
  'split' { PT _ (TS _ 38) }
  'split@' { PT _ (TS _ 39) }
  'transparent' { PT _ (TS _ 40) }
  'transparent_all' { PT _ (TS _ 41) }
  'transport' { PT _ (TS _ 42) }
  'undefined' { PT _ (TS _ 43) }
  'unglue' { PT _ (TS _ 44) }
  'where' { PT _ (TS _ 45) }
  'with' { PT _ (TS _ 46) }
  '{' { PT _ (TS _ 47) }
  '|' { PT _ (TS _ 48) }
  '}' { PT _ (TS _ 49) }

L_AIdent { PT _ (T_AIdent _) }
L_CIdent { PT _ (T_CIdent $$) }
L_HoleIdent { PT _ (T_HoleIdent _) }


%%

AIdent    :: { AIdent} : L_AIdent { AIdent (mkPosToken $1)}
CIdent    :: { CIdent} : L_CIdent { CIdent ($1)}
HoleIdent    :: { HoleIdent} : L_HoleIdent { HoleIdent (mkPosToken $1)}

Module :: { Module }
Module : 'module' AIdent 'where' '{' ListImp ListDecl '}' { Exp.Abs.Module $2 $5 $6 }
Imp :: { Imp }
Imp : 'import' AIdent { Exp.Abs.Import $2 }
ListImp :: { [Imp] }
ListImp : {- empty -} { [] }
        | Imp { (:[]) $1 }
        | Imp ';' ListImp { (:) $1 $3 }
Decl :: { Decl }
Decl : AIdent ListTele ':' Exp '=' ExpWhere { Exp.Abs.DeclDef $1 (reverse $2) $4 $6 }
     | 'data' AIdent ListTele '=' ListLabel { Exp.Abs.DeclData $2 (reverse $3) $5 }
     | 'hdata' AIdent ListTele '=' ListLabel { Exp.Abs.DeclHData $2 (reverse $3) $5 }
     | AIdent ListTele ':' Exp '=' 'split' '{' ListBranch '}' { Exp.Abs.DeclSplit $1 (reverse $2) $4 $8 }
     | AIdent ListTele ':' Exp '=' 'undefined' { Exp.Abs.DeclUndef $1 (reverse $2) $4 }
     | 'mutual' '{' ListDecl '}' { Exp.Abs.DeclMutual $3 }
     | 'opaque' AIdent { Exp.Abs.DeclOpaque $2 }
     | 'transparent' AIdent { Exp.Abs.DeclTransparent $2 }
     | 'transparent_all' { Exp.Abs.DeclTransparentAll }
ListDecl :: { [Decl] }
ListDecl : {- empty -} { [] }
         | Decl { (:[]) $1 }
         | Decl ';' ListDecl { (:) $1 $3 }
ExpWhere :: { ExpWhere }
ExpWhere : Exp 'where' '{' ListDecl '}' { Exp.Abs.Where $1 $4 }
         | Exp { Exp.Abs.NoWhere $1 }
Exp :: { Exp }
Exp : 'let' '{' ListDecl '}' 'in' Exp { Exp.Abs.Let $3 $6 }
    | '\\' ListPTele '->' Exp { Exp.Abs.Lam $2 $4 }
    | '<' ListAIdent '>' Exp { Exp.Abs.PLam $2 $4 }
    | 'split@' Exp 'with' '{' ListBranch '}' { Exp.Abs.Split $2 $5 }
    | Exp1 { $1 }
Exp1 :: { Exp }
Exp1 : Exp2 '->' Exp1 { Exp.Abs.Fun $1 $3 }
     | ListPTele '->' Exp1 { Exp.Abs.Pi $1 $3 }
     | ListPTele '*' Exp1 { Exp.Abs.Sigma $1 $3 }
     | Exp2 { $1 }
Exp2 :: { Exp }
Exp2 : Exp2 '@' Formula { Exp.Abs.AppFormula $1 $3 }
     | Exp2 Exp3 { Exp.Abs.App $1 $2 }
     | Exp3 { $1 }
Exp3 :: { Exp }
Exp3 : 'PathP' Exp4 Exp4 Exp4 { Exp.Abs.PathP $2 $3 $4 }
     | 'comp' Exp4 Exp4 System { Exp.Abs.Comp $2 $3 $4 }
     | 'transport' Exp4 Exp4 { Exp.Abs.Trans $2 $3 }
     | 'fill' Exp4 Exp4 System { Exp.Abs.Fill $2 $3 $4 }
     | 'Glue' Exp4 System { Exp.Abs.Glue $2 $3 }
     | 'glue' Exp4 System { Exp.Abs.GlueElem $2 $3 }
     | 'unglue' Exp4 System { Exp.Abs.UnGlueElem $2 $3 }
     | 'Id' Exp4 Exp4 Exp3 { Exp.Abs.Id $2 $3 $4 }
     | 'idC' Exp4 System { Exp.Abs.IdPair $2 $3 }
     | 'idJ' Exp4 Exp4 Exp4 Exp4 Exp4 Exp4 { Exp.Abs.IdJ $2 $3 $4 $5 $6 $7 }
     | Exp4 { $1 }
Exp4 :: { Exp }
Exp4 : Exp4 '.1' { Exp.Abs.Fst $1 }
     | Exp4 '.2' { Exp.Abs.Snd $1 }
     | Exp5 { $1 }
Exp5 :: { Exp }
Exp5 : '(' Exp ',' ListExp ')' { Exp.Abs.Pair $2 $4 }
     | AIdent { Exp.Abs.Var $1 }
     | AIdent '{' Exp '}' { Exp.Abs.PCon $1 $3 }
     | 'U' { Exp.Abs.U }
     | HoleIdent { Exp.Abs.Hole $1 }
     | '(' Exp ')' { $2 }
ListExp :: { [Exp] }
ListExp : Exp { (:[]) $1 } | Exp ',' ListExp { (:) $1 $3 }
Dir :: { Dir }
Dir : '0' { Exp.Abs.Dir0 } | '1' { Exp.Abs.Dir1 }
System :: { System }
System : '[' ListSide ']' { Exp.Abs.System $2 }
Face :: { Face }
Face : '(' AIdent '=' Dir ')' { Exp.Abs.Face $2 $4 }
ListFace :: { [Face] }
ListFace : {- empty -} { [] } | ListFace Face { flip (:) $1 $2 }
Side :: { Side }
Side : ListFace '->' Exp { Exp.Abs.Side (reverse $1) $3 }
ListSide :: { [Side] }
ListSide : {- empty -} { [] }
         | Side { (:[]) $1 }
         | Side ',' ListSide { (:) $1 $3 }
Formula :: { Formula }
Formula : Formula '\\/' Formula1 { Exp.Abs.Disj $1 $3 }
        | Formula1 { $1 }
Formula1 :: { Formula }
Formula1 : Formula1 CIdent Formula2 { Exp.Abs.Conj $1 $2 $3 }
         | Formula2 { $1 }
Formula2 :: { Formula }
Formula2 : '-' Formula2 { Exp.Abs.Neg $2 }
         | AIdent { Exp.Abs.Atom $1 }
         | Dir { Exp.Abs.Dir $1 }
         | '(' Formula ')' { $2 }
Branch :: { Branch }
Branch : AIdent ListAIdent '->' ExpWhere { Exp.Abs.OBranch $1 $2 $4 }
       | AIdent ListAIdent '@' ListAIdent '->' ExpWhere { Exp.Abs.PBranch $1 $2 $4 $6 }
ListBranch :: { [Branch] }
ListBranch : {- empty -} { [] }
           | Branch { (:[]) $1 }
           | Branch ';' ListBranch { (:) $1 $3 }
Label :: { Label }
Label : AIdent ListTele { Exp.Abs.OLabel $1 (reverse $2) }
      | AIdent ListTele '<' ListAIdent '>' System { Exp.Abs.PLabel $1 (reverse $2) $4 $6 }
ListLabel :: { [Label] }
ListLabel : {- empty -} { [] }
          | Label { (:[]) $1 }
          | Label '|' ListLabel { (:) $1 $3 }
Tele :: { Tele }
Tele : '(' AIdent ListAIdent ':' Exp ')' { Exp.Abs.Tele $2 $3 $5 }
ListTele :: { [Tele] }
ListTele : {- empty -} { [] } | ListTele Tele { flip (:) $1 $2 }
PTele :: { PTele }
PTele : '(' Exp ':' Exp ')' { Exp.Abs.PTele $2 $4 }
ListPTele :: { [PTele] }
ListPTele : PTele { (:[]) $1 } | PTele ListPTele { (:) $1 $2 }
ListAIdent :: { [AIdent] }
ListAIdent : {- empty -} { [] } | AIdent ListAIdent { (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

